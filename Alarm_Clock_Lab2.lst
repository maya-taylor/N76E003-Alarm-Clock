0000              1   ;ALARM CLOCK on N76E003
0000              2   ;Date: Jan 27, 2024
0000              3   ;Author: Maya Taylor
0000              4   ;Features:
0000              5   ;Can adjust the clocks hours, minutes, seconds and AM/PM
0000              6   ;Can adjust the alarm's hours, minutes, AM/PM and set it/turn it on
0000              7   ;Alarm will not go off if not in "ON" mode
0000              8   ;When alarm goes off it will ask you a boolean algebra question and evaluate your response
0000              9   ;If your response is incorrect, you will receive a "Think Harder!!" message
0000             10   ;Alarm will only turn off if you enter the answer correctly
0000             11   ;Note: buttons can be held down to increase
0000             12   
0000             13   ;using R1 for clk AM/PM
0000             14   ;using R2 for alarm AM/PM
0000             15   ;using R3 for alarm on or off
0000             16   
                 18   $LIST
0000             20   
0000             21   ;  N76E003 pinout:
0000             22   ;                               -------
0000             23   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             24   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             25   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             26   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             27   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             28   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             29   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             30   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             31   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             32   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             33   ;                               -------
0000             34   ;
0000             35   
0000             36   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             37   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             38   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             39   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             40   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             41   
0000             42   HR_BUTTON     equ P1.6
0000             43   MIN_BUTTON    equ P1.5
0000             44   SEC_BUTTON    equ P1.0 ;also used for inputting alarm answer
0000             45   AM_PM         equ P1.1
0000             46   SET_IT             equ P1.2
0000             47   SOUND_OUT     equ P1.7
0000             48   
0000             49   ; Reset vector
0000             50   org 0x0000
0000 020271      51       ljmp main
0003             52   
0003             53   ; External interrupt 0 vector (not used in this code)
0003             54   org 0x0003
0003 32          55            reti
0004             56   
0004             57   ; Timer/Counter 0 overflow interrupt vector
000B             58   org 0x000B
000B 0201CE      59            ljmp Timer0_ISR
000E             60   
000E             61   ; External interrupt 1 vector (not used in this code)
0013             62   org 0x0013
0013 32          63            reti
0014             64   
0014             65   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             66   org 0x001B
001B 32          67            reti
001C             68   
001C             69   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             70   org 0x0023 
0023 32          71            reti
0024             72            
0024             73   ; Timer/Counter 2 overflow interrupt vector
002B             74   org 0x002B
002B 0201F8      75            ljmp Timer2_ISR
002E             76   
002E             77   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             78   dseg at 0x30
0030             79   Count1ms:     ds 2 ; Used to determine when half second has passed
0032             80   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033             81   BCD_counter1:  ds 1 ; The BCD counter incrememted minutes
0034             82   BCD_counter2:  ds 1 ; The BCD counter incrememted hours
0035             83   
0035             84   BCD_counter_temp:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0036             85   BCD_counter1_temp:  ds 1 ; The BCD counter incrememted minutes
0037             86   BCD_counter2_temp:  ds 1 ; The BCD counter incrememted hours
0038             87   
0038             88   BCD_alarm_min:  ds 1 ; The BCD counter incrememted minutes
0039             89   BCD_alarm_hour:  ds 1 ; The BCD counter incrememted hours
003A             90   
003A             91   clk_am_pm: ds 1 ;stores whether the clock is in AM or PM mode
003B             92   alarm_am_pm: ds 1 ;stores whether the alarm is in AM or PM mode
003C             93   
003C             94   alarm_ans: ds 1 ;stores the answer being entered into the Alarm question
003D             95   q_count: ds 1 ;keeps track of how which question to ask on the next alarm
003E             96   
003E             97   
003E             98   
0000             99   bseg
0000            100   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            101   
002E            102   cseg
002E            103   ; These 'equ' must match the hardware wiring
002E            104   LCD_RS equ P1.3
002E            105   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            106   LCD_E  equ P1.4
002E            107   LCD_D4 equ P0.0
002E            108   LCD_D5 equ P0.1
002E            109   LCD_D6 equ P0.2
002E            110   LCD_D7 equ P0.3
002E            111   
                113   	$LIST
00E2            115   
00E2            116   ;                     1234567890123456    <- This helps determine the location of the counter
00E2 54696D65   117   Initial_Message:  db 'Time  xx:xx:xx A', 0
     20207878
     3A78783A
     78782041
     00
00F3 416C6172   118   Initial_Message2: db 'Alarm xx:xx A --', 0
     6D207878
     3A787820
     41202D2D
     00
0104 416C6172   119   Alarm_On: db         'Alarm xx:xx A on', 0
     6D207878
     3A787820
     41206F6E
     00
0115 416C6172   120   Alarm_Off: db        'Alarm xx:xx A --', 0
     6D207878
     3A787820
     41202D2D
     00
0126 4100       121   AM : db 'A', 0
0128 5000       122   PM : db 'P', 0
012A            123   
012A 20203130   124   ALARM_1: db          '  1011 & 1100?   ', 0
     31312026
     20313130
     303F2020
     2000
013C 414E5357   125   ALARM_2: db          'ANSWER IN DEC:     ', 0
     45522049
     4E204445
     433A2020
     20202000
0150            126            ;answer is 1000 which is 8
0150 20544849   127   FAIL_1: db           ' THINK HARDER!!   ', 0
     4E4B2048
     41524445
     52212120
     202000
0163 20202020   128   FAIL_2: db           '                  ', 0
     20202020
     20202020
     20202020
     202000
0176            129   
0176 20203030   130   ALARM_3: db          '  0011 ^ 0101?  ', 0
     3131205E
     20303130
     313F2020
     00
0187 414E5357   131   ALARM_4: db          'ANSWER IN DEC:  ', 0
     45522049
     4E204445
     433A2020
     00
0198            132   ;answer is 0110, which is 6
0198            133   
0198 20203030   134   ALARM_5: db          '  0011 | 0101?  ', 0
     3131207C
     20303130
     313F2020
     00
01A9 414E5357   135   ALARM_6: db          'ANSWER IN DEC:  ', 0
     45522049
     4E204445
     433A2020
     00
01BA            136            ;answer is 0111 which is 7
01BA            137   ;---------------------------------;
01BA            138   ; Routine to initialize the ISR   ;
01BA            139   ; for timer 0                     ;
01BA            140   ;---------------------------------;
01BA            141   
01BA            142   Timer0_Init:
01BA 438E08     143            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
01BD E589       144            mov a, TMOD
01BF 54F0       145            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
01C1 4401       146            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
01C3 F589       147            mov TMOD, a
01C5 758CF0     148            mov TH0, #high(TIMER0_RELOAD)
01C8 758A2C     149            mov TL0, #low(TIMER0_RELOAD)
01CB            150            ; Enable the timer and interrupts
01CB            151       ;setb ET0  ; Enable timer 0 interrupt
01CB D28C       152       setb TR0  ; Start timer 0
01CD 22         153            ret
01CE            154   
01CE            155   ;---------------------------------;
01CE            156   ; ISR for timer 0.  Set to execute;
01CE            157   ; every 1/4096Hz to generate a    ;
01CE            158   ; 2048 Hz wave at pin SOUND_OUT   ;
01CE            159   ;---------------------------------;
01CE            160   
01CE            161   ;This ISR only goes off when the alarm is sounding
01CE            162   Timer0_ISR:
01CE            163            ;clr TF0  ; According to the data sheet this is done for us already.
01CE            164            ; Timer 0 doesn't have 16-bit auto-reload, so
01CE C28C       165            clr TR0
01D0 758CF0     166            mov TH0, #high(TIMER0_RELOAD)
01D3 758A2C     167            mov TL0, #low(TIMER0_RELOAD)
01D6            168   
01D6 D28C       169            setb TR0        
01D8 B297       170            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
01DA 32         171            reti
01DB            172   
01DB            173   ;---------------------------------;
01DB            174   ; Routine to initialize the ISR   ;
01DB            175   ; for timer 2                     ;
01DB            176   ;---------------------------------;
01DB            177   Timer2_Init:
01DB 75C800     178            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
01DE 75CDBF     179            mov TH2, #high(TIMER2_RELOAD)
01E1 75CC28     180            mov TL2, #low(TIMER2_RELOAD)
01E4            181            ; Set the reload value
01E4 43C980     182            orl T2MOD, #0x80 ; Enable timer 2 autoreload
01E7 75CBBF     183            mov RCMP2H, #high(TIMER2_RELOAD)
01EA 75CA28     184            mov RCMP2L, #low(TIMER2_RELOAD)
01ED            185            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
01ED E4         186            clr a
01EE F530       187            mov Count1ms+0, a
01F0 F531       188            mov Count1ms+1, a
01F2            189            ; Enable the timer and interrupts
01F2 439B80     190            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
01F5 D2CA       191       setb TR2  ; Enable timer 2
01F7 22         192            ret
01F8            193   
01F8            194   ;---------------------------------;
01F8            195   ; ISR for timer 2                 ;
01F8            196   ;---------------------------------;
01F8            197   Timer2_ISR:
01F8 C2CF       198            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
01FA B284       199            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
01FC            200            
01FC            201            ; The two registers used in the ISR must be saved in the stack
01FC C0E0       202            push acc
01FE C0D0       203            push psw
0200            204            
0200            205            ; Increment the 16-bit one mili second counter
0200 0530       206            inc Count1ms+0    ; Increment the low 8-bits first
0202 E530       207            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0204 7002       208            jnz Inc_Done
0206 0531       209            inc Count1ms+1
0208            210   
0208            211   Inc_Done:
0208            212            ; Check if half second has passed
0208 E530       213            mov a, Count1ms+0
020A B4E802     214            cjne a, #low(1000), Timer2_ISR_done_extend
020D 8003       215            sjmp jump_fix_inc
020F            216            ;CHANGE THIS TO 500 FOR 1/2 A SECOND
020F            217   Timer2_ISR_done_extend:
020F 02026C     218            ljmp Timer2_ISR_done
0212            219            
0212            220   jump_fix_inc:
0212 E531       221            mov a, Count1ms+1
0214 B40355     222            cjne a, #high(1000), Timer2_ISR_done
0217            223            ;CHANGE THIS TO 500 FOR 1/2 A SECOND
0217            224            
0217            225            ; 500 milliseconds have passed.  Set a flag so the main program knows
0217 D200       226            setb half_seconds_flag ; Let the main program know half second had passed
0219 B28C       227            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
021B            228            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
021B E4         229            clr a
021C F530       230            mov Count1ms+0, a
021E F531       231            mov Count1ms+1, a
0220            232            ; Increment the BCD counter
0220 E532       233            mov a, BCD_counter
0222            234            ;jnb UPDOWN, Timer2_ISR_decrement
0222 2401       235            add a, #0x01
0224 8000       236            sjmp Timer2_ISR_da
0226            237   
0226            238   Timer2_ISR_da:
0226 D4         239            da a ; Decimal adjust instruction.  Check datasheet for more details!
0227 F532       240            mov BCD_counter, a
0229            241   
0229            242   ;this is checking the overflows of the seconds
0229            243   check_if_60:
0229 E532       244            mov a, BCD_counter
022B B4603C     245            cjne a, #0x60, skip_hours ;number 60
022E 753200     246            mov BCD_counter, #0x00
0231            247            
0231            248   continue_check_if_60:
0231 C2CA       249            clr TR2                 ; Stop timer 2
0233 E4         250            clr a
0234 F530       251            mov Count1ms+0, a
0236 F531       252            mov Count1ms+1, a       
0238            253            ; Now clear the BCD counter (seconds counter)
0238            254            
0238 E533       255            mov a, BCD_counter1 ;incrementing the minutes
023A 2401       256            add a, #0x01
023C D4         257            da a
023D            258            
023D B46024     259            cjne a, #0x60, do_not_rst_mins ;making it clr if minutes too high
0240 E4         260            clr a
0241 7400       261            mov a, #0x00
0243 D4         262            da a
0244 F533       263            mov BCD_counter1, a
0246            264            
0246            265            ;increment hours
0246 E534       266            mov a, BCD_counter2
0248 2401       267            add a, #0x01
024A D4         268            da a
024B B4131A     269            cjne a, #0x13, do_not_rst_hours ;making it clr if hours too high
024E E4         270            clr a
024F 7401       271            mov a, #0x01
0251 D4         272            da a
0252 F534       273            mov BCD_counter2, a
0254            274            
0254 E4         275            clr a
0255 E53A       276            mov a, clk_am_pm
0257 B40005     277            cjne a, #0x00, overflow_to_am
025A            278            ;adding a sequence to chnage from AM to PM
025A            279            
025A            280   overflow_to_pm:
025A 753A01     281            mov clk_am_pm, #0x01            
025D 800B       282            sjmp skip_hours
025F            283            
025F            284   overflow_to_am:
025F 753A00     285            mov clk_am_pm, #0x00
0262 8006       286            sjmp skip_hours
0264            287   
0264            288   do_not_rst_mins:
0264 F533       289            mov BCD_counter1, a
0266 8002       290            sjmp skip_hours
0268            291   
0268            292   do_not_rst_hours:
0268 F534       293            mov BCD_counter2, a
026A            294            
026A            295   skip_hours:
026A D2CA       296            setb TR2                ; Start timer 2
026C            297   
026C            298   
026C            299   Timer2_ISR_done:
026C D0D0       300            pop psw
026E D0E0       301            pop acc
0270 32         302            reti
0271            303   
0271            304   
0271            305   ;---------------------------------;
0271            306   ; Main program. Includes hardware ;
0271            307   ; initialization and 'forever'    ;
0271            308   ; loop.                           ;
0271            309   ;---------------------------------;
0271            310   main:
0271            311            ; Initialization
0271 75817F     312       mov SP, #0x7F
0274 75B100     313       mov P0M1, #0x00
0277 75B200     314       mov P0M2, #0x00
027A 75B300     315       mov P1M1, #0x00
027D 75B400     316       mov P1M2, #0x00
0280 75AD00     317       mov P3M2, #0x00
0283 75AD00     318       mov P3M2, #0x00
0286            319             
0286 1201BA     320       lcall Timer0_Init
0289 1201DB     321       lcall Timer2_Init
028C D2AF       322       setb EA   ; Enable Global interrupts
028E 120087     323       lcall LCD_4BIT
0291            324       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
0291 C0E0       325            push acc
0293 7401       325            mov a, #1
0295 14         325            dec a
0296 1200C7     325            lcall ?Set_Cursor_1 ; Select column and row
0299 D0E0       325            pop acc
029B C083       326            push dph
029D C082       326            push dpl
029F C0E0       326            push acc
02A1 9000E2     326            mov dptr, #Initial_Message
02A4 1200BA     326            lcall ?Send_Constant_String
02A7 D0E0       326            pop acc
02A9 D082       326            pop dpl
02AB D083       326            pop dph
02AD            327       
02AD C0E0       328            push acc
02AF 7401       328            mov a, #1
02B1 14         328            dec a
02B2 1200C5     328            lcall ?Set_Cursor_2 ; Select column and row
02B5 D0E0       328            pop acc
02B7 C083       329            push dph
02B9 C082       329            push dpl
02BB C0E0       329            push acc
02BD 9000F3     329            mov dptr, #Initial_Message2
02C0 1200BA     329            lcall ?Send_Constant_String
02C3 D0E0       329            pop acc
02C5 D082       329            pop dpl
02C7 D083       329            pop dph
02C9            330       
02C9 D200       331       setb half_seconds_flag
02CB 753500     332            mov BCD_counter_temp, #0x00
02CE 753600     333            mov BCD_counter1_temp, #0x00
02D1 753701     334            mov BCD_counter2_temp, #0x01
02D4            335   
02D4 753800     336            mov BCD_alarm_min, #0x00
02D7 753901     337            mov BCD_alarm_hour, #0x01
02DA            338            
02DA 753B00     339            mov alarm_am_pm, #0x00
02DD 753A00     340            mov clk_am_pm, #0x00
02E0 753D00     341            mov q_count, #0x00
02E3 7B00       342            mov R3, #0x00
02E5 7C00       343            mov R4, #0x00
02E7            344            
02E7            345   setting_time: ;this is where all the clock times are set
02E7            346            
02E7            347   check_hour:      
02E7 C0E0       348            push acc
02E9 7407       348            mov a, #7
02EB 14         348            dec a
02EC 1200C7     348            lcall ?Set_Cursor_1 ; Select column and row
02EF D0E0       348            pop acc
02F1 C000       349            push ar0
02F3 A837       349            mov r0, BCD_counter2_temp
02F5 1200CC     349            lcall ?Display_BCD
02F8 D000       349            pop ar0
02FA            350            
02FA 20961E     351            jb HR_BUTTON, check_mins  ; if the 'CLEAR' button is not pressed skip
02FD C002       352            push AR2
02FF 7A64       352            mov R2, #100
0301 120038     352            lcall ?Wait_Milli_Seconds
0304 D002       352            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0306 209612     353            jb HR_BUTTON, check_mins ; if the 'CLEAR' button is not pressed skip
0309            354            
0309 E537       355            mov a, BCD_counter2_temp ;incrementing the minutes
030B 2401       356            add a, #0x01
030D D4         357            da a
030E            358            
030E B41308     359            cjne a, #0x13, no_o_flow_hr  ;making it clr if hour too high
0311 E4         360            clr a
0312 7401       361            mov a, #0x01
0314 D4         362            da a
0315 F537       363            mov BCD_counter2_temp, a
0317            364            
0317 8002       365            sjmp check_mins
0319            366            ;need to deal with overflow
0319            367   no_o_flow_hr:
0319 F537       368            mov BCD_counter2_temp, a
031B            369   
031B            370   check_mins:      
031B C0E0       371            push acc
031D 740A       371            mov a, #10
031F 14         371            dec a
0320 1200C7     371            lcall ?Set_Cursor_1 ; Select column and row
0323 D0E0       371            pop acc
0325 C000       372            push ar0
0327 A836       372            mov r0, BCD_counter1_temp
0329 1200CC     372            lcall ?Display_BCD
032C D000       372            pop ar0
032E            373            
032E 20951C     374            jb MIN_BUTTON, check_secs  ; if the 'CLEAR' button is not pressed skip
0331 C002       375            push AR2
0333 7A64       375            mov R2, #100
0335 120038     375            lcall ?Wait_Milli_Seconds
0338 D002       375            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
033A 209510     376            jb MIN_BUTTON, check_secs ; if the 'CLEAR' button is not pressed skip
033D            377            
033D E536       378            mov a, BCD_counter1_temp ;incrementing the minutes
033F 2401       379            add a, #0x01
0341 D4         380            da a
0342            381            
0342 B46006     382            cjne a, #0x60, no_o_flow_min  ;making it clr if minutes too high
0345 E4         383            clr a
0346 7400       384            mov a, #0x00
0348 D4         385            da a
0349 F536       386            mov BCD_counter1_temp, a
034B            387            
034B            388   no_o_flow_min:
034B F536       389            mov BCD_counter1_temp, a
034D            390            
034D            391   check_secs:      
034D C0E0       392            push acc
034F 740D       392            mov a, #13
0351 14         392            dec a
0352 1200C7     392            lcall ?Set_Cursor_1 ; Select column and row
0355 D0E0       392            pop acc
0357 C000       393            push ar0
0359 A835       393            mov r0, BCD_counter_temp
035B 1200CC     393            lcall ?Display_BCD
035E D000       393            pop ar0
0360            394            
0360 20901C     395            jb SEC_BUTTON, check_am_pm  ; if the 'CLEAR' button is not pressed skip
0363 C002       396            push AR2
0365 7A64       396            mov R2, #100
0367 120038     396            lcall ?Wait_Milli_Seconds
036A D002       396            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
036C 209010     397            jb SEC_BUTTON, check_am_pm ; if the 'CLEAR' button is not pressed skip
036F            398            
036F E535       399            mov a, BCD_counter_temp ;incrementing the minutes
0371 2401       400            add a, #0x01
0373 D4         401            da a
0374            402            
0374 B46006     403            cjne a, #0x60, no_o_flow_sec  ;making it clr if minutes too high
0377 E4         404            clr a
0378 7400       405            mov a, #0x00
037A D4         406            da a
037B F535       407            mov BCD_counter_temp, a
037D            408            
037D            409   no_o_flow_sec:
037D F535       410            mov BCD_counter_temp, a
037F            411            
037F            412   check_am_pm:
037F 209143     413            jb AM_PM, check_set  ; if the 'CLEAR' button is not pressed skip
0382 C002       414            push AR2
0384 7A96       414            mov R2, #150
0386 120038     414            lcall ?Wait_Milli_Seconds
0389 D002       414            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
038B 209137     415            jb AM_PM, check_set ; if the 'CLEAR' button is not pressed skip
038E            416            
038E            417            ;have R1 be whether the clk is AM or PM
038E            418            ;if R1 is 0 it is AM, if its 1 its PM
038E E53A       419            mov a, clk_am_pm
0390 701B       420            jnz change_to_am
0392            421            
0392            422   change_to_pm:
0392 753A01     423            mov clk_am_pm, #0x01
0395 C0E0       424            push acc
0397 7410       424            mov a, #16
0399 14         424            dec a
039A 1200C7     424            lcall ?Set_Cursor_1 ; Select column and row
039D D0E0       424            pop acc
039F C0E0       425            push acc
03A1 7450       425            mov a, #'P'
03A3 12007D     425            lcall ?WriteData
03A6 D0E0       425            pop acc                 
03A8 801B       426            sjmp check_set
03AA            427            
03AA            428   jump_extend: ;extending the jump to setting time
03AA 0202E7     429            ljmp setting_time       
03AD            430            
03AD            431   change_to_am:
03AD 753A00     432            mov clk_am_pm, #0x0
03B0 C0E0       433            push acc
03B2 7410       433            mov a, #16
03B4 14         433            dec a
03B5 1200C7     433            lcall ?Set_Cursor_1 ; Select column and row
03B8 D0E0       433            pop acc
03BA C0E0       434            push acc
03BC 7441       434            mov a, #'A'
03BE 12007D     434            lcall ?WriteData
03C1 D0E0       434            pop acc
03C3 8000       435            sjmp check_set
03C5            436            
03C5            437   check_set:       
03C5 2092E2     438            jb SET_IT, jump_extend  ; if the 'SET_IT' button is not pressed skip
03C8 C002       439            push AR2
03CA 7A32       439            mov R2, #50
03CC 120038     439            lcall ?Wait_Milli_Seconds
03CF D002       439            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03D1 2092D6     440            jb SET_IT, jump_extend ; if the 'SET_IT' button is not pressed skip
03D4            441            
03D4 7B00       442            mov R3, #0
03D6            443            
03D6            444            ;moving the counters over to their real counterparts which are used by Timer 2
03D6            445            ;the temp variables helped prevent the timer from increasing them as they were being entered
03D6 C0E0       446            push acc
03D8 7401       446            mov a, #1
03DA 14         446            dec a
03DB 1200C5     446            lcall ?Set_Cursor_2 ; Select column and row
03DE D0E0       446            pop acc
03E0 853532     447            mov BCD_Counter, BCD_Counter_temp
03E3 853633     448            mov BCD_Counter1, BCD_Counter1_temp
03E6 853734     449            mov BCD_Counter2, BCD_Counter2_temp
03E9 C083       450            push dph
03EB C082       450            push dpl
03ED C0E0       450            push acc
03EF 900115     450            mov dptr, #Alarm_Off
03F2 1200BA     450            lcall ?Send_Constant_String
03F5 D0E0       450            pop acc
03F7 D082       450            pop dpl
03F9 D083       450            pop dph;string to say alarm is in off mode
03FB            451            
03FB            452            ; After initialization the program stays in this 'forever' loop
03FB            453   loop:
03FB            454                    
03FB            455       
03FB            456   check_clk_am_set:
03FB E53A       457            mov a, clk_am_pm
03FD 7015       458            jnz set_clk_pm
03FF            459            
03FF            460   set_clk_am:      
03FF C0E0       461            push acc
0401 7410       461            mov a, #16
0403 14         461            dec a
0404 1200C7     461            lcall ?Set_Cursor_1 ; Select column and row
0407 D0E0       461            pop acc
0409 C0E0       462            push acc
040B 7441       462            mov a, #'A'
040D 12007D     462            lcall ?WriteData
0410 D0E0       462            pop acc
0412 8013       463            sjmp check_alarm_hour
0414            464            
0414            465   set_clk_pm:
0414 C0E0       466            push acc
0416 7410       466            mov a, #16
0418 14         466            dec a
0419 1200C7     466            lcall ?Set_Cursor_1 ; Select column and row
041C D0E0       466            pop acc
041E C0E0       467            push acc
0420 7450       467            mov a, #'P'
0422 12007D     467            lcall ?WriteData
0425 D0E0       467            pop acc
0427            468            
0427            469   
0427            470   check_alarm_hour:        
0427 C0E0       471            push acc
0429 7407       471            mov a, #7
042B 14         471            dec a
042C 1200C5     471            lcall ?Set_Cursor_2 ; Select column and row
042F D0E0       471            pop acc
0431 C000       472            push ar0
0433 A839       472            mov r0, BCD_alarm_hour
0435 1200CC     472            lcall ?Display_BCD
0438 D000       472            pop ar0
043A            473            
043A 20961E     474            jb HR_BUTTON, check_alarm_mins  ; if the 'CLEAR' button is not pressed skip
043D C002       475            push AR2
043F 7A64       475            mov R2, #100
0441 120038     475            lcall ?Wait_Milli_Seconds
0444 D002       475            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0446 209612     476            jb HR_BUTTON, check_alarm_mins ; if the 'CLEAR' button is not pressed skip
0449            477            
0449 E539       478            mov a, BCD_alarm_hour ;incrementing the minutes
044B 2401       479            add a, #0x01
044D D4         480            da a
044E            481            
044E B41308     482            cjne a, #0x13, no_o_flow_alarm_hr  ;making it clr if hour too high
0451 E4         483            clr a
0452 7401       484            mov a, #0x01
0454 D4         485            da a
0455 F539       486            mov BCD_alarm_hour, a
0457            487            
0457 8002       488            sjmp check_alarm_mins
0459            489            ;need to deal with overflow
0459            490   no_o_flow_alarm_hr:
0459 F539       491            mov BCD_alarm_hour, a
045B            492   
045B            493   check_alarm_mins:        
045B C0E0       494            push acc
045D 740A       494            mov a, #10
045F 14         494            dec a
0460 1200C5     494            lcall ?Set_Cursor_2 ; Select column and row
0463 D0E0       494            pop acc
0465 C000       495            push ar0
0467 A838       495            mov r0, BCD_alarm_min
0469 1200CC     495            lcall ?Display_BCD
046C D000       495            pop ar0
046E            496            
046E 20951C     497            jb MIN_BUTTON, check_alarm_am_pm  ; if the 'CLEAR' button is not pressed skip
0471 C002       498            push AR2
0473 7A64       498            mov R2, #100
0475 120038     498            lcall ?Wait_Milli_Seconds
0478 D002       498            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
047A 209510     499            jb MIN_BUTTON, check_alarm_am_pm ; if the 'CLEAR' button is not pressed skip
047D            500            
047D E538       501            mov a, BCD_alarm_min ;incrementing the minutes
047F 2401       502            add a, #0x01
0481 D4         503            da a
0482            504            
0482 B46006     505            cjne a, #0x60, no_o_flow_alarm_min  ;making it clr if minutes too high
0485 E4         506            clr a
0486 7400       507            mov a, #0x00
0488 D4         508            da a
0489 F538       509            mov BCD_alarm_min, a
048B            510            
048B            511   no_o_flow_alarm_min:
048B F538       512            mov BCD_alarm_min, a
048D            513            
048D            514   check_alarm_am_pm:
048D 20913E     515            jb AM_PM, check_alarm_set  ; if the 'CLEAR' button is not pressed skip
0490 C002       516            push AR2
0492 7AFA       516            mov R2, #250
0494 120038     516            lcall ?Wait_Milli_Seconds
0497 D002       516            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0499 209132     517            jb AM_PM, check_alarm_set ; if the 'CLEAR' button is not pressed skip
049C            518            
049C            519            ;have R1 be whether the clk is AM or PM
049C            520            ;if R1 is 0 it is AM, if its 1 its PM
049C E53B       521            mov a, alarm_am_pm
049E 7018       522            jnz change_to_alarm_am
04A0            523            
04A0            524   change_to_alarm_pm:
04A0 753B01     525            mov alarm_am_pm, #0x1
04A3 C0E0       526            push acc
04A5 740D       526            mov a, #13
04A7 14         526            dec a
04A8 1200C5     526            lcall ?Set_Cursor_2 ; Select column and row
04AB D0E0       526            pop acc
04AD C0E0       527            push acc
04AF 7450       527            mov a, #'P'
04B1 12007D     527            lcall ?WriteData
04B4 D0E0       527            pop acc                 
04B6 8016       528            sjmp check_alarm_set
04B8            529   
04B8            530            
04B8            531   change_to_alarm_am:
04B8 753B00     532            mov alarm_am_pm, #0x0
04BB C0E0       533            push acc
04BD 740D       533            mov a, #13
04BF 14         533            dec a
04C0 1200C5     533            lcall ?Set_Cursor_2 ; Select column and row
04C3 D0E0       533            pop acc
04C5 C0E0       534            push acc
04C7 7441       534            mov a, #'A'
04C9 12007D     534            lcall ?WriteData
04CC D0E0       534            pop acc
04CE            535            ;sjmp check_set
04CE            536            
04CE            537   check_alarm_set:
04CE            538            
04CE E53B       539            mov a, alarm_am_pm
04D0 7015       540            jnz set_pm
04D2            541            
04D2            542   set_am:  
04D2 C0E0       543            push acc
04D4 740D       543            mov a, #13
04D6 14         543            dec a
04D7 1200C5     543            lcall ?Set_Cursor_2 ; Select column and row
04DA D0E0       543            pop acc
04DC C0E0       544            push acc
04DE 7441       544            mov a, #'A'
04E0 12007D     544            lcall ?WriteData
04E3 D0E0       544            pop acc
04E5 8013       545            sjmp display
04E7            546            
04E7            547   set_pm:
04E7 C0E0       548            push acc
04E9 740D       548            mov a, #13
04EB 14         548            dec a
04EC 1200C5     548            lcall ?Set_Cursor_2 ; Select column and row
04EF D0E0       548            pop acc
04F1 C0E0       549            push acc
04F3 7450       549            mov a, #'P'
04F5 12007D     549            lcall ?WriteData
04F8 D0E0       549            pop acc
04FA            550            
04FA            551            
04FA            552   display:
04FA C0E0       553            push acc
04FC 740D       553            mov a, #13
04FE 14         553            dec a
04FF 1200C7     553            lcall ?Set_Cursor_1 ; Select column and row
0502 D0E0       553            pop acc     ; the place in the LCD where we want the BCD counter value
0504 C000       554            push ar0
0506 A832       554            mov r0, BCD_counter
0508 1200CC     554            lcall ?Display_BCD
050B D000       554            pop ar0 ; This macro is also in 'LCD_4bit.inc'
050D            555            
050D C0E0       556            push acc
050F 740A       556            mov a, #10
0511 14         556            dec a
0512 1200C7     556            lcall ?Set_Cursor_1 ; Select column and row
0515 D0E0       556            pop acc
0517 C000       557            push ar0
0519 A833       557            mov r0, BCD_counter1
051B 1200CC     557            lcall ?Display_BCD
051E D000       557            pop ar0
0520            558            
0520 C0E0       559            push acc
0522 7407       559            mov a, #7
0524 14         559            dec a
0525 1200C7     559            lcall ?Set_Cursor_1 ; Select column and row
0528 D0E0       559            pop acc
052A C000       560            push ar0
052C A834       560            mov r0, BCD_counter2
052E 1200CC     560            lcall ?Display_BCD
0531 D000       560            pop ar0
0533            561            
0533 C0E0       562            push acc
0535 740A       562            mov a, #10
0537 14         562            dec a
0538 1200C5     562            lcall ?Set_Cursor_2 ; Select column and row
053B D0E0       562            pop acc
053D C000       563            push ar0
053F A838       563            mov r0, BCD_alarm_min
0541 1200CC     563            lcall ?Display_BCD
0544 D000       563            pop ar0
0546            564            
0546 C0E0       565            push acc
0548 7407       565            mov a, #7
054A 14         565            dec a
054B 1200C5     565            lcall ?Set_Cursor_2 ; Select column and row
054E D0E0       565            pop acc
0550 C000       566            push ar0
0552 A839       566            mov r0, BCD_alarm_hour
0554 1200CC     566            lcall ?Display_BCD
0557 D000       566            pop ar0
0559            567   
0559            568   check_the_alarm:
0559            569            ;check if AM/PM the same: R2 stores alarm, R1 stores clk
0559            570            ;check if hours the same
0559 209252     571            jb SET_IT, check_if_alarm_set  ; if the 'CLEAR' button is not pressed skip
055C C002       572            push AR2
055E 7A64       572            mov R2, #100
0560 120038     572            lcall ?Wait_Milli_Seconds
0563 D002       572            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0565 209246     573            jb SET_IT, check_if_alarm_set
0568            574            
0568 EB         575            mov a, R3 ;checking whether alarm is set
0569 B40122     576            cjne a, #1, set_alarm_on
056C            577                    
056C            578   turn_alarm_off:
056C E4         579            clr a
056D 7400       580            mov a, #0x00
056F FB         581            mov R3, a
0570            582            
0570 C0E0       583            push acc
0572 7401       583            mov a, #1
0574 14         583            dec a
0575 1200C5     583            lcall ?Set_Cursor_2 ; Select column and row
0578 D0E0       583            pop acc
057A C083       584            push dph
057C C082       584            push dpl
057E C0E0       584            push acc
0580 900115     584            mov dptr, #Alarm_Off
0583 1200BA     584            lcall ?Send_Constant_String
0586 D0E0       584            pop acc
0588 D082       584            pop dpl
058A D083       584            pop dph
058C 8020       585            sjmp check_if_alarm_set
058E            586            
058E            587   set_alarm_on:
058E E4         588            clr a
058F 7401       589            mov a, #0x01
0591 FB         590            mov R3, a
0592            591            
0592 C0E0       592            push acc
0594 7401       592            mov a, #1
0596 14         592            dec a
0597 1200C5     592            lcall ?Set_Cursor_2 ; Select column and row
059A D0E0       592            pop acc
059C C083       593            push dph
059E C082       593            push dpl
05A0 C0E0       593            push acc
05A2 900104     593            mov dptr, #Alarm_On
05A5 1200BA     593            lcall ?Send_Constant_String
05A8 D0E0       593            pop acc
05AA D082       593            pop dpl
05AC D083       593            pop dph         
05AE            594   
05AE            595   
05AE            596   check_if_alarm_set:
05AE EB         597            mov a, R3
05AF B4012A     598            cjne a, #0x01, no_alarm
05B2            599                    
05B2            600   comp_am_pm: ;whether alarm am and pm are the same as the clock's
05B2 E53A       601            mov a, clk_am_pm
05B4 953B       602            subb a, alarm_am_pm
05B6 D4         603            da a 
05B7 B40022     604            cjne a, #0x00, no_alarm
05BA            605            
05BA E53B       606            mov a, alarm_am_pm
05BC 953A       607            subb a, clk_am_pm
05BE D4         608            da a 
05BF B4001A     609            cjne a, #0x00, no_alarm
05C2            610   
05C2            611   comp_hour:;whether alarm's hours are the same as the clock's
05C2 E534       612            mov a, BCD_counter2
05C4 9539       613            subb a, BCD_alarm_hour
05C6 D4         614            da a 
05C7 B40012     615            cjne a, #0x00, no_alarm
05CA            616            
05CA E539       617            mov a, BCD_alarm_hour
05CC 9534       618            subb a, BCD_counter2
05CE D4         619            da a 
05CF B4000A     620            cjne a, #0x00, no_alarm
05D2            621   
05D2            622   comp_min:;whether alarm's minutes are the same as the clock's
05D2 E533       623            mov a, BCD_counter1
05D4 9538       624            subb a, BCD_alarm_min
05D6 D4         625            da a 
05D7 B40002     626            cjne a, #0x00, no_alarm
05DA 8003       627            sjmp sound_the_alarm
05DC            628                    
05DC            629   no_alarm:
05DC 02086B     630            ljmp loop_a ;skip the alarm sequence
05DF            631            
05DF            632            
05DF            633   sound_the_alarm:
05DF BB01FA     634            cjne R3, #0x01, no_alarm ;safety measure to ensure alarm does not go off incorrectly
05E2 753C00     635            mov alarm_ans, #0x00
05E5            636            
05E5 D2A9       637            setb ET0  ; Enable timer 0 interrupt, timer zero interrupt sounds the alarm
05E7            638   
05E7            639            ;check which message should be displayed
05E7 E53D       640            mov a, q_count
05E9 B4003B     641            cjne a, #0x00, question_1_disp
05EC            642            
05EC            643   question_0_disp:
05EC C0E0       644            push acc
05EE 7401       644            mov a, #1
05F0 14         644            dec a
05F1 1200C7     644            lcall ?Set_Cursor_1 ; Select column and row
05F4 D0E0       644            pop acc
05F6 C083       645            push dph
05F8 C082       645            push dpl
05FA C0E0       645            push acc
05FC 90012A     645            mov dptr, #ALARM_1
05FF 1200BA     645            lcall ?Send_Constant_String
0602 D0E0       645            pop acc
0604 D082       645            pop dpl
0606 D083       645            pop dph
0608 C0E0       646            push acc
060A 7401       646            mov a, #1
060C 14         646            dec a
060D 1200C5     646            lcall ?Set_Cursor_2 ; Select column and row
0610 D0E0       646            pop acc
0612 C083       647            push dph
0614 C082       647            push dpl
0616 C0E0       647            push acc
0618 90013C     647            mov dptr, #ALARM_2
061B 1200BA     647            lcall ?Send_Constant_String
061E D0E0       647            pop acc
0620 D082       647            pop dpl
0622 D083       647            pop dph
0624 02073D     648            ljmp check_ans_button
0627            649            
0627            650   question_1_disp:
0627 B4013B     651            cjne a, #0x01, question_2_disp
062A C0E0       652            push acc
062C 7401       652            mov a, #1
062E 14         652            dec a
062F 1200C7     652            lcall ?Set_Cursor_1 ; Select column and row
0632 D0E0       652            pop acc
0634 C083       653            push dph
0636 C082       653            push dpl
0638 C0E0       653            push acc
063A 900176     653            mov dptr, #ALARM_3
063D 1200BA     653            lcall ?Send_Constant_String
0640 D0E0       653            pop acc
0642 D082       653            pop dpl
0644 D083       653            pop dph
0646 C0E0       654            push acc
0648 7401       654            mov a, #1
064A 14         654            dec a
064B 1200C5     654            lcall ?Set_Cursor_2 ; Select column and row
064E D0E0       654            pop acc
0650 C083       655            push dph
0652 C082       655            push dpl
0654 C0E0       655            push acc
0656 900187     655            mov dptr, #ALARM_4
0659 1200BA     655            lcall ?Send_Constant_String
065C D0E0       655            pop acc
065E D082       655            pop dpl
0660 D083       655            pop dph
0662 02073D     656            ljmp check_ans_button
0665            657            
0665            658   question_2_disp:
0665 C0E0       659            push acc
0667 7401       659            mov a, #1
0669 14         659            dec a
066A 1200C7     659            lcall ?Set_Cursor_1 ; Select column and row
066D D0E0       659            pop acc
066F C083       660            push dph
0671 C082       660            push dpl
0673 C0E0       660            push acc
0675 900198     660            mov dptr, #ALARM_5
0678 1200BA     660            lcall ?Send_Constant_String
067B D0E0       660            pop acc
067D D082       660            pop dpl
067F D083       660            pop dph
0681 C0E0       661            push acc
0683 7401       661            mov a, #1
0685 14         661            dec a
0686 1200C5     661            lcall ?Set_Cursor_2 ; Select column and row
0689 D0E0       661            pop acc
068B C083       662            push dph
068D C082       662            push dpl
068F C0E0       662            push acc
0691 9001A9     662            mov dptr, #ALARM_6
0694 1200BA     662            lcall ?Send_Constant_String
0697 D0E0       662            pop acc
0699 D082       662            pop dpl
069B D083       662            pop dph
069D 02073D     663            ljmp check_ans_button           
06A0            664            
06A0            665   fail_message:
06A0 C0E0       666            push acc
06A2 7401       666            mov a, #1
06A4 14         666            dec a
06A5 1200C7     666            lcall ?Set_Cursor_1 ; Select column and row
06A8 D0E0       666            pop acc
06AA C083       667            push dph
06AC C082       667            push dpl
06AE C0E0       667            push acc
06B0 900150     667            mov dptr, #FAIL_1
06B3 1200BA     667            lcall ?Send_Constant_String
06B6 D0E0       667            pop acc
06B8 D082       667            pop dpl
06BA D083       667            pop dph
06BC C0E0       668            push acc
06BE 7401       668            mov a, #1
06C0 14         668            dec a
06C1 1200C5     668            lcall ?Set_Cursor_2 ; Select column and row
06C4 D0E0       668            pop acc
06C6 C083       669            push dph
06C8 C082       669            push dpl
06CA C0E0       669            push acc
06CC 900163     669            mov dptr, #FAIL_2
06CF 1200BA     669            lcall ?Send_Constant_String
06D2 D0E0       669            pop acc
06D4 D082       669            pop dpl
06D6 D083       669            pop dph
06D8 C002       670            push AR2
06DA 7AC8       670            mov R2, #200
06DC 120038     670            lcall ?Wait_Milli_Seconds
06DF D002       670            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'                 
06E1 C002       671            push AR2
06E3 7AC8       671            mov R2, #200
06E5 120038     671            lcall ?Wait_Milli_Seconds
06E8 D002       671            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
06EA C002       672            push AR2
06EC 7AC8       672            mov R2, #200
06EE 120038     672            lcall ?Wait_Milli_Seconds
06F1 D002       672            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
06F3 C002       673            push AR2
06F5 7AC8       673            mov R2, #200
06F7 120038     673            lcall ?Wait_Milli_Seconds
06FA D002       673            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
06FC C002       674            push AR2
06FE 7AC8       674            mov R2, #200
0700 120038     674            lcall ?Wait_Milli_Seconds
0703 D002       674            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0705 C0E0       675            push acc
0707 7401       675            mov a, #1
0709 14         675            dec a
070A 1200C7     675            lcall ?Set_Cursor_1 ; Select column and row
070D D0E0       675            pop acc
070F C083       676            push dph
0711 C082       676            push dpl
0713 C0E0       676            push acc
0715 90012A     676            mov dptr, #ALARM_1
0718 1200BA     676            lcall ?Send_Constant_String
071B D0E0       676            pop acc
071D D082       676            pop dpl
071F D083       676            pop dph
0721 C0E0       677            push acc
0723 7401       677            mov a, #1
0725 14         677            dec a
0726 1200C5     677            lcall ?Set_Cursor_2 ; Select column and row
0729 D0E0       677            pop acc
072B C083       678            push dph
072D C082       678            push dpl
072F C0E0       678            push acc
0731 90013C     678            mov dptr, #ALARM_2
0734 1200BA     678            lcall ?Send_Constant_String
0737 D0E0       678            pop acc
0739 D082       678            pop dpl
073B D083       678            pop dph
073D            679            
073D            680   check_ans_button:
073D            681            
073D C0E0       682            push acc
073F 740F       682            mov a, #15
0741 14         682            dec a
0742 1200C5     682            lcall ?Set_Cursor_2 ; Select column and row
0745 D0E0       682            pop acc
0747 C000       683            push ar0
0749 A83C       683            mov r0, alarm_ans
074B 1200CC     683            lcall ?Display_BCD
074E D000       683            pop ar0
0750            684            
0750 209024     685            jb SEC_BUTTON, check_ans ; if the 'CLEAR' button is not pressed skip
0753 C002       686            push AR2
0755 7A64       686            mov R2, #100
0757 120038     686            lcall ?Wait_Milli_Seconds
075A D002       686            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
075C 209018     687            jb SEC_BUTTON, check_ans ; if the 'CLEAR' button is not pressed skip
075F            688            
075F E53C       689            mov a, alarm_ans ;incrementing the minutes
0761 2401       690            add a, #0x01
0763 D4         691            da a
0764            692            
0764 B41006     693            cjne a, #0x10, no_o_flow_ans  ;making it clr if minutes too high
0767 E4         694            clr a
0768 7400       695            mov a, #0x00
076A D4         696            da a
076B F53C       697            mov alarm_ans, a
076D            698            
076D            699            
076D            700   no_o_flow_ans:
076D F53C       701            mov alarm_ans, a
076F 8006       702            sjmp check_ans
0771            703            
0771            704   check_ans_button_extend:
0771 02073D     705            ljmp check_ans_button
0774            706   
0774            707   fail_message_extend: ;can't reach
0774 0206A0     708            ljmp fail_message
0777            709   
0777            710   check_ans:
0777            711            ;using the set_button
0777 2092F7     712            jb SET_IT, check_ans_button_extend ; if the 'SET_IT' button is not pressed skip
077A C002       713            push AR2
077C 7A64       713            mov R2, #100
077E 120038     713            lcall ?Wait_Milli_Seconds
0781 D002       713            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0783 2092EB     714            jb SET_IT, check_ans_button_extend ; if the 'SET_IT' button is not pressed skip         
0786            715            
0786            716            ;if answer is right continue
0786 E53D       717            mov a, q_count
0788 B40016     718            cjne a, #0x00, question_1_check
078B            719            
078B            720   question_0_check: ;want answer 8         
078B E53C       721            mov a, alarm_ans
078D 9408       722            subb a, #0x08
078F D4         723            da a 
0790 B400E1     724            cjne a, #0x00, fail_message_extend
0793 7408       725            mov a, #0x08
0795            726            
0795 953C       727            subb a, alarm_ans
0797 D4         728            da a 
0798 B400D9     729            cjne a, #0x00, fail_message_extend
079B 753D01     730            mov q_count, #0x01
079E 0207D0     731            ljmp question_passed
07A1            732            
07A1            733   question_1_check:
07A1 B40116     734            cjne a, #0x01, question_2_check
07A4 E53C       735            mov a, alarm_ans
07A6 9406       736            subb a, #0x06
07A8 D4         737            da a 
07A9 B400C8     738            cjne a, #0x00, fail_message_extend
07AC 7406       739            mov a, #0x06
07AE            740            
07AE 953C       741            subb a, alarm_ans
07B0 D4         742            da a 
07B1 B400C0     743            cjne a, #0x00, fail_message_extend
07B4 753D02     744            mov q_count, #0x02
07B7 0207D0     745            ljmp question_passed
07BA            746            
07BA            747   question_2_check:
07BA E53C       748            mov a, alarm_ans
07BC 9407       749            subb a, #0x07
07BE D4         750            da a 
07BF B400B2     751            cjne a, #0x00, fail_message_extend
07C2 7407       752            mov a, #0x07
07C4            753            
07C4 953C       754            subb a, alarm_ans
07C6 D4         755            da a 
07C7 B400AA     756            cjne a, #0x00, fail_message_extend
07CA 753D00     757            mov q_count, #0x00
07CD 0207D0     758            ljmp question_passed
07D0            759            
07D0            760   question_passed:         
07D0 7B00       761            mov R3, #0x00
07D2 C2A9       762            clr ET0  ; Enable timer 0 interrupt
07D4            763            
07D4 C0E0       764            push acc
07D6 7401       764            mov a, #1
07D8 14         764            dec a
07D9 1200C7     764            lcall ?Set_Cursor_1 ; Select column and row
07DC D0E0       764            pop acc
07DE C083       765            push dph
07E0 C082       765            push dpl
07E2 C0E0       765            push acc
07E4 9000E2     765            mov dptr, #Initial_Message
07E7 1200BA     765            lcall ?Send_Constant_String
07EA D0E0       765            pop acc
07EC D082       765            pop dpl
07EE D083       765            pop dph
07F0            766       
07F0 C0E0       767            push acc
07F2 7401       767            mov a, #1
07F4 14         767            dec a
07F5 1200C5     767            lcall ?Set_Cursor_2 ; Select column and row
07F8 D0E0       767            pop acc
07FA C083       768            push dph
07FC C082       768            push dpl
07FE C0E0       768            push acc
0800 9000F3     768            mov dptr, #Initial_Message2
0803 1200BA     768            lcall ?Send_Constant_String
0806 D0E0       768            pop acc
0808 D082       768            pop dpl
080A D083       768            pop dph         
080C            769       
080C C0E0       770            push acc
080E 740D       770            mov a, #13
0810 14         770            dec a
0811 1200C7     770            lcall ?Set_Cursor_1 ; Select column and row
0814 D0E0       770            pop acc     ; the place in the LCD where we want the BCD counter value
0816 C000       771            push ar0
0818 A832       771            mov r0, BCD_counter
081A 1200CC     771            lcall ?Display_BCD
081D D000       771            pop ar0 ; This macro is also in 'LCD_4bit.inc'
081F            772            
081F C0E0       773            push acc
0821 740A       773            mov a, #10
0823 14         773            dec a
0824 1200C7     773            lcall ?Set_Cursor_1 ; Select column and row
0827 D0E0       773            pop acc
0829 C000       774            push ar0
082B A833       774            mov r0, BCD_counter1
082D 1200CC     774            lcall ?Display_BCD
0830 D000       774            pop ar0
0832            775            
0832 C0E0       776            push acc
0834 7407       776            mov a, #7
0836 14         776            dec a
0837 1200C7     776            lcall ?Set_Cursor_1 ; Select column and row
083A D0E0       776            pop acc
083C C000       777            push ar0
083E A834       777            mov r0, BCD_counter2
0840 1200CC     777            lcall ?Display_BCD
0843 D000       777            pop ar0
0845            778            
0845 C0E0       779            push acc
0847 740A       779            mov a, #10
0849 14         779            dec a
084A 1200C5     779            lcall ?Set_Cursor_2 ; Select column and row
084D D0E0       779            pop acc
084F C000       780            push ar0
0851 A838       780            mov r0, BCD_alarm_min
0853 1200CC     780            lcall ?Display_BCD
0856 D000       780            pop ar0
0858            781            
0858 C0E0       782            push acc
085A 7407       782            mov a, #7
085C 14         782            dec a
085D 1200C5     782            lcall ?Set_Cursor_2 ; Select column and row
0860 D0E0       782            pop acc
0862 C000       783            push ar0
0864 A839       783            mov r0, BCD_alarm_hour
0866 1200CC     783            lcall ?Display_BCD
0869 D000       783            pop ar0
086B            784   
086B            785   loop_a:
086B            786   
086B 300002     787            jnb half_seconds_flag, loop_extend
086E 8003       788            sjmp loop_b
0870            789            
0870            790            
0870            791   loop_extend:
0870 0203FB     792            ljmp loop
0873            793   loop_b:
0873 C200       794            clr half_seconds_flag 
0875 0203FB     795       ljmp loop
0878            796   END
