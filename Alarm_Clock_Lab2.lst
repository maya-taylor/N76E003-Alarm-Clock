0000              1   ;ALARM CLOCK on N76E003
0000              2   ;Date: Jan 27, 2024
0000              3   ;Author: Maya Taylor
0000              4   ;Features:
0000              5   ;Can adjust the clocks hours, minutes, seconds and AM/PM
0000              6   ;Can adjust the alarm's hours, minutes, AM/PM and set it/turn it on
0000              7   ;Alarm will not go off if not in "ON" mode
0000              8   ;When alarm goes off it will ask you a boolean algebra question and evaluate your response
0000              9   ;If your response is incorrect, you will receive a "Think Harder!!" message
0000             10   ;Alarm will only turn off if you enter the answer correctly
0000             11   ;Note: buttons can be held down to increase
0000             12   
0000             13   ;using R1 for clk AM/PM
0000             14   ;using R2 for alarm AM/PM
0000             15   ;using R3 for alarm on or off
0000             16   
                 18   $LIST
0000             20   
0000             21   ;  N76E003 pinout:
0000             22   ;                               -------
0000             23   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             24   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             25   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             26   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             27   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             28   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             29   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             30   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             31   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             32   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             33   ;                               -------
0000             34   ;
0000             35   
0000             36   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             37   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             38   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             39   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             40   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             41   
0000             42   HR_BUTTON     equ P1.6
0000             43   MIN_BUTTON    equ P1.5
0000             44   SEC_BUTTON    equ P1.0 ;also used for inputting alarm answer
0000             45   AM_PM         equ P1.1
0000             46   SET_IT             equ P1.2
0000             47   SOUND_OUT     equ P1.7
0000             48   
0000             49   ; Reset vector
0000             50   org 0x0000
0000 020276      51       ljmp main
0003             52   
0003             53   ; External interrupt 0 vector (not used in this code)
0003             54   org 0x0003
0003 32          55            reti
0004             56   
0004             57   ; Timer/Counter 0 overflow interrupt vector
000B             58   org 0x000B
000B 0201CE      59            ljmp Timer0_ISR
000E             60   
000E             61   ; External interrupt 1 vector (not used in this code)
0013             62   org 0x0013
0013 32          63            reti
0014             64   
0014             65   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             66   org 0x001B
001B 32          67            reti
001C             68   
001C             69   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             70   org 0x0023 
0023 32          71            reti
0024             72            
0024             73   ; Timer/Counter 2 overflow interrupt vector
002B             74   org 0x002B
002B 0201F8      75            ljmp Timer2_ISR
002E             76   
002E             77   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             78   dseg at 0x30
0030             79   Count1ms:     ds 2 ; Used to determine when half second has passed
0032             80   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033             81   BCD_counter1:  ds 1 ; The BCD counter incrememted minutes
0034             82   BCD_counter2:  ds 1 ; The BCD counter incrememted hours
0035             83   
0035             84   BCD_counter_temp:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0036             85   BCD_counter1_temp:  ds 1 ; The BCD counter incrememted minutes
0037             86   BCD_counter2_temp:  ds 1 ; The BCD counter incrememted hours
0038             87   
0038             88   BCD_alarm_min:  ds 1 ; The BCD counter incrememted minutes
0039             89   BCD_alarm_hour:  ds 1 ; The BCD counter incrememted hours
003A             90   
003A             91   clk_am_pm: ds 1 ;stores whether the clock is in AM or PM mode
003B             92   alarm_am_pm: ds 1 ;stores whether the alarm is in AM or PM mode
003C             93   
003C             94   alarm_ans: ds 1 ;stores the answer being entered into the Alarm question
003D             95   q_count: ds 1 ;keeps track of how which question to ask on the next alarm
003E             96   
003E             97   
003E             98   
0000             99   bseg
0000            100   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            101   
002E            102   cseg
002E            103   ; These 'equ' must match the hardware wiring
002E            104   LCD_RS equ P1.3
002E            105   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            106   LCD_E  equ P1.4
002E            107   LCD_D4 equ P0.0
002E            108   LCD_D5 equ P0.1
002E            109   LCD_D6 equ P0.2
002E            110   LCD_D7 equ P0.3
002E            111   
                113   	$LIST
00E2            115   
00E2            116   ;                     1234567890123456    <- This helps determine the location of the counter
00E2 54696D65   117   Initial_Message:  db 'Time  xx:xx:xx A', 0
     20207878
     3A78783A
     78782041
     00
00F3 416C6172   118   Initial_Message2: db 'Alarm xx:xx A --', 0
     6D207878
     3A787820
     41202D2D
     00
0104 416C6172   119   Alarm_On: db         'Alarm xx:xx A on', 0
     6D207878
     3A787820
     41206F6E
     00
0115 416C6172   120   Alarm_Off: db        'Alarm xx:xx A --', 0
     6D207878
     3A787820
     41202D2D
     00
0126 4100       121   AM : db 'A', 0
0128 5000       122   PM : db 'P', 0
012A            123   
012A 20203130   124   ALARM_1: db          '  1011 & 1100?   ', 0
     31312026
     20313130
     303F2020
     2000
013C 414E5357   125   ALARM_2: db          'ANSWER IN DEC:     ', 0
     45522049
     4E204445
     433A2020
     20202000
0150            126            ;answer is 1000 which is 8
0150 20544849   127   FAIL_1: db           ' THINK HARDER!!   ', 0
     4E4B2048
     41524445
     52212120
     202000
0163 20202020   128   FAIL_2: db           '                  ', 0
     20202020
     20202020
     20202020
     202000
0176            129   
0176 20203030   130   ALARM_3: db          '  0011 ^ 0101?  ', 0
     3131205E
     20303130
     313F2020
     00
0187 414E5357   131   ALARM_4: db          'ANSWER IN DEC:  ', 0
     45522049
     4E204445
     433A2020
     00
0198            132   ;answer is 0110, which is 6
0198            133   
0198 20203030   134   ALARM_5: db          '  0011 | 0101?  ', 0
     3131207C
     20303130
     313F2020
     00
01A9 414E5357   135   ALARM_6: db          'ANSWER IN DEC:  ', 0
     45522049
     4E204445
     433A2020
     00
01BA            136            ;answer is 0111 which is 7
01BA            137   ;---------------------------------;
01BA            138   ; Routine to initialize the ISR   ;
01BA            139   ; for timer 0                     ;
01BA            140   ;---------------------------------;
01BA            141   
01BA            142   Timer0_Init:
01BA 438E08     143            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
01BD E589       144            mov a, TMOD
01BF 54F0       145            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
01C1 4401       146            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
01C3 F589       147            mov TMOD, a
01C5 758CF0     148            mov TH0, #high(TIMER0_RELOAD)
01C8 758A2C     149            mov TL0, #low(TIMER0_RELOAD)
01CB            150            ; Enable the timer and interrupts
01CB            151       ;setb ET0  ; Enable timer 0 interrupt
01CB D28C       152       setb TR0  ; Start timer 0
01CD 22         153            ret
01CE            154   
01CE            155   ;---------------------------------;
01CE            156   ; ISR for timer 0.  Set to execute;
01CE            157   ; every 1/4096Hz to generate a    ;
01CE            158   ; 2048 Hz wave at pin SOUND_OUT   ;
01CE            159   ;---------------------------------;
01CE            160   
01CE            161   ;This ISR only goes off when the alarm is sounding
01CE            162   Timer0_ISR:
01CE            163            ;clr TF0  ; According to the data sheet this is done for us already.
01CE            164            ; Timer 0 doesn't have 16-bit auto-reload, so
01CE C28C       165            clr TR0
01D0 758CF0     166            mov TH0, #high(TIMER0_RELOAD)
01D3 758A2C     167            mov TL0, #low(TIMER0_RELOAD)
01D6            168   
01D6 D28C       169            setb TR0        
01D8 B297       170            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
01DA 32         171            reti
01DB            172   
01DB            173   ;---------------------------------;
01DB            174   ; Routine to initialize the ISR   ;
01DB            175   ; for timer 2                     ;
01DB            176   ;---------------------------------;
01DB            177   Timer2_Init:
01DB 75C800     178            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
01DE 75CDBF     179            mov TH2, #high(TIMER2_RELOAD)
01E1 75CC28     180            mov TL2, #low(TIMER2_RELOAD)
01E4            181            ; Set the reload value
01E4 43C980     182            orl T2MOD, #0x80 ; Enable timer 2 autoreload
01E7 75CBBF     183            mov RCMP2H, #high(TIMER2_RELOAD)
01EA 75CA28     184            mov RCMP2L, #low(TIMER2_RELOAD)
01ED            185            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
01ED E4         186            clr a
01EE F530       187            mov Count1ms+0, a
01F0 F531       188            mov Count1ms+1, a
01F2            189            ; Enable the timer and interrupts
01F2 439B80     190            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
01F5 D2CA       191       setb TR2  ; Enable timer 2
01F7 22         192            ret
01F8            193   
01F8            194   ;---------------------------------;
01F8            195   ; ISR for timer 2                 ;
01F8            196   ;---------------------------------;
01F8            197   Timer2_ISR:
01F8 C2CF       198            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
01FA B284       199            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
01FC            200            
01FC            201            ; The two registers used in the ISR must be saved in the stack
01FC C0E0       202            push acc
01FE C0D0       203            push psw
0200            204            
0200            205            ; Increment the 16-bit one mili second counter
0200 0530       206            inc Count1ms+0    ; Increment the low 8-bits first
0202 E530       207            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0204 7002       208            jnz Inc_Done
0206 0531       209            inc Count1ms+1
0208            210   
0208            211   Inc_Done:
0208            212            ; Check if half second has passed
0208 E530       213            mov a, Count1ms+0
020A B4E802     214            cjne a, #low(1000), Timer2_ISR_done_extend
020D 8003       215            sjmp jump_fix_inc
020F            216            ;CHANGE THIS TO 500 FOR 1/2 A SECOND
020F            217   Timer2_ISR_done_extend:
020F 020271     218            ljmp Timer2_ISR_done
0212            219            
0212            220   jump_fix_inc:
0212 E531       221            mov a, Count1ms+1
0214 B4035A     222            cjne a, #high(1000), Timer2_ISR_done
0217            223            ;CHANGE THIS TO 500 FOR 1/2 A SECOND
0217            224            
0217            225            ; 500 milliseconds have passed.  Set a flag so the main program knows
0217 D200       226            setb half_seconds_flag ; Let the main program know half second had passed
0219 B28C       227            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
021B            228            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
021B E4         229            clr a
021C F530       230            mov Count1ms+0, a
021E F531       231            mov Count1ms+1, a
0220            232            ; Increment the BCD counter
0220 E532       233            mov a, BCD_counter
0222            234            ;jnb UPDOWN, Timer2_ISR_decrement
0222 2401       235            add a, #0x01
0224 8000       236            sjmp Timer2_ISR_da
0226            237   
0226            238   Timer2_ISR_da:
0226 D4         239            da a ; Decimal adjust instruction.  Check datasheet for more details!
0227 F532       240            mov BCD_counter, a
0229            241   
0229            242   ;this is checking the overflows of the seconds
0229            243   check_if_60:
0229 E532       244            mov a, BCD_counter
022B B46041     245            cjne a, #0x60, skip_hours ;number 60
022E 753200     246            mov BCD_counter, #0x00
0231            247            
0231            248   continue_check_if_60:
0231 C2CA       249            clr TR2                 ; Stop timer 2
0233 E4         250            clr a
0234 F530       251            mov Count1ms+0, a
0236 F531       252            mov Count1ms+1, a       
0238            253            ; Now clear the BCD counter (seconds counter)
0238            254            
0238 E533       255            mov a, BCD_counter1 ;incrementing the minutes
023A 2401       256            add a, #0x01
023C D4         257            da a
023D            258            
023D B46016     259            cjne a, #0x60, do_not_rst_mins ;making it clr if minutes too high
0240 E4         260            clr a
0241 7400       261            mov a, #0x00
0243 D4         262            da a
0244 F533       263            mov BCD_counter1, a
0246            264            
0246            265            ;increment hours
0246 E534       266            mov a, BCD_counter2
0248 2401       267            add a, #0x01
024A D4         268            da a
024B B4130C     269            cjne a, #0x13, do_not_rst_hours ;making it clr if hours too high
024E E4         270            clr a
024F 7401       271            mov a, #0x01
0251 D4         272            da a
0252 F534       273            mov BCD_counter2, a
0254 8019       274            sjmp skip_hours
0256            275            
0256            276            ;clr a
0256            277            ;mov a, clk_am_pm
0256            278            ;cjne a, #0x00, overflow_to_am
0256            279            ;adding a sequence to chnage from AM to PM
0256            280   
0256            281   do_not_rst_mins:
0256 F533       282            mov BCD_counter1, a
0258 8015       283            sjmp skip_hours
025A            284   
025A            285   do_not_rst_hours:
025A F534       286            mov BCD_counter2, a
025C B41210     287            cjne a, #0x12, skip_hours
025F E4         288            clr a
0260 E53A       289            mov a, clk_am_pm
0262 B40005     290            cjne a, #0x00, overflow_to_am
0265            291            
0265            292   overflow_to_pm:
0265 753A01     293            mov clk_am_pm, #0x01            
0268 8005       294            sjmp skip_hours
026A            295            
026A            296   overflow_to_am:
026A 753A00     297            mov clk_am_pm, #0x00
026D 8000       298            sjmp skip_hours
026F            299            
026F            300            
026F            301   skip_hours:
026F D2CA       302            setb TR2                ; Start timer 2
0271            303   
0271            304   
0271            305   Timer2_ISR_done:
0271 D0D0       306            pop psw
0273 D0E0       307            pop acc
0275 32         308            reti
0276            309   
0276            310   
0276            311   ;---------------------------------;
0276            312   ; Main program. Includes hardware ;
0276            313   ; initialization and 'forever'    ;
0276            314   ; loop.                           ;
0276            315   ;---------------------------------;
0276            316   main:
0276            317            ; Initialization
0276 75817F     318       mov SP, #0x7F
0279 75B100     319       mov P0M1, #0x00
027C 75B200     320       mov P0M2, #0x00
027F 75B300     321       mov P1M1, #0x00
0282 75B400     322       mov P1M2, #0x00
0285 75AD00     323       mov P3M2, #0x00
0288 75AD00     324       mov P3M2, #0x00
028B            325             
028B 1201BA     326       lcall Timer0_Init
028E 1201DB     327       lcall Timer2_Init
0291 D2AF       328       setb EA   ; Enable Global interrupts
0293 120087     329       lcall LCD_4BIT
0296            330       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
0296 C0E0       331            push acc
0298 7401       331            mov a, #1
029A 14         331            dec a
029B 1200C7     331            lcall ?Set_Cursor_1 ; Select column and row
029E D0E0       331            pop acc
02A0 C083       332            push dph
02A2 C082       332            push dpl
02A4 C0E0       332            push acc
02A6 9000E2     332            mov dptr, #Initial_Message
02A9 1200BA     332            lcall ?Send_Constant_String
02AC D0E0       332            pop acc
02AE D082       332            pop dpl
02B0 D083       332            pop dph
02B2            333       
02B2 C0E0       334            push acc
02B4 7401       334            mov a, #1
02B6 14         334            dec a
02B7 1200C5     334            lcall ?Set_Cursor_2 ; Select column and row
02BA D0E0       334            pop acc
02BC C083       335            push dph
02BE C082       335            push dpl
02C0 C0E0       335            push acc
02C2 9000F3     335            mov dptr, #Initial_Message2
02C5 1200BA     335            lcall ?Send_Constant_String
02C8 D0E0       335            pop acc
02CA D082       335            pop dpl
02CC D083       335            pop dph
02CE            336       
02CE D200       337       setb half_seconds_flag
02D0 753500     338            mov BCD_counter_temp, #0x00
02D3 753600     339            mov BCD_counter1_temp, #0x00
02D6 753701     340            mov BCD_counter2_temp, #0x01
02D9            341   
02D9 753800     342            mov BCD_alarm_min, #0x00
02DC 753901     343            mov BCD_alarm_hour, #0x01
02DF            344            
02DF 753B00     345            mov alarm_am_pm, #0x00
02E2 753A00     346            mov clk_am_pm, #0x00
02E5 753D00     347            mov q_count, #0x00
02E8 7B00       348            mov R3, #0x00
02EA 7C00       349            mov R4, #0x00
02EC            350            
02EC            351   setting_time: ;this is where all the clock times are set
02EC            352            
02EC            353   check_hour:      
02EC C0E0       354            push acc
02EE 7407       354            mov a, #7
02F0 14         354            dec a
02F1 1200C7     354            lcall ?Set_Cursor_1 ; Select column and row
02F4 D0E0       354            pop acc
02F6 C000       355            push ar0
02F8 A837       355            mov r0, BCD_counter2_temp
02FA 1200CC     355            lcall ?Display_BCD
02FD D000       355            pop ar0
02FF            356            
02FF 20961E     357            jb HR_BUTTON, check_mins  ; if the 'CLEAR' button is not pressed skip
0302 C002       358            push AR2
0304 7A64       358            mov R2, #100
0306 120038     358            lcall ?Wait_Milli_Seconds
0309 D002       358            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
030B 209612     359            jb HR_BUTTON, check_mins ; if the 'CLEAR' button is not pressed skip
030E            360            
030E E537       361            mov a, BCD_counter2_temp ;incrementing the minutes
0310 2401       362            add a, #0x01
0312 D4         363            da a
0313            364            
0313 B41308     365            cjne a, #0x13, no_o_flow_hr  ;making it clr if hour too high
0316 E4         366            clr a
0317 7401       367            mov a, #0x01
0319 D4         368            da a
031A F537       369            mov BCD_counter2_temp, a
031C            370            
031C 8002       371            sjmp check_mins
031E            372            ;need to deal with overflow
031E            373   no_o_flow_hr:
031E F537       374            mov BCD_counter2_temp, a
0320            375   
0320            376   check_mins:      
0320 C0E0       377            push acc
0322 740A       377            mov a, #10
0324 14         377            dec a
0325 1200C7     377            lcall ?Set_Cursor_1 ; Select column and row
0328 D0E0       377            pop acc
032A C000       378            push ar0
032C A836       378            mov r0, BCD_counter1_temp
032E 1200CC     378            lcall ?Display_BCD
0331 D000       378            pop ar0
0333            379            
0333 20951C     380            jb MIN_BUTTON, check_secs  ; if the 'CLEAR' button is not pressed skip
0336 C002       381            push AR2
0338 7A64       381            mov R2, #100
033A 120038     381            lcall ?Wait_Milli_Seconds
033D D002       381            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
033F 209510     382            jb MIN_BUTTON, check_secs ; if the 'CLEAR' button is not pressed skip
0342            383            
0342 E536       384            mov a, BCD_counter1_temp ;incrementing the minutes
0344 2401       385            add a, #0x01
0346 D4         386            da a
0347            387            
0347 B46006     388            cjne a, #0x60, no_o_flow_min  ;making it clr if minutes too high
034A E4         389            clr a
034B 7400       390            mov a, #0x00
034D D4         391            da a
034E F536       392            mov BCD_counter1_temp, a
0350            393            
0350            394   no_o_flow_min:
0350 F536       395            mov BCD_counter1_temp, a
0352            396            
0352            397   check_secs:      
0352 C0E0       398            push acc
0354 740D       398            mov a, #13
0356 14         398            dec a
0357 1200C7     398            lcall ?Set_Cursor_1 ; Select column and row
035A D0E0       398            pop acc
035C C000       399            push ar0
035E A835       399            mov r0, BCD_counter_temp
0360 1200CC     399            lcall ?Display_BCD
0363 D000       399            pop ar0
0365            400            
0365 20901C     401            jb SEC_BUTTON, check_am_pm  ; if the 'CLEAR' button is not pressed skip
0368 C002       402            push AR2
036A 7A64       402            mov R2, #100
036C 120038     402            lcall ?Wait_Milli_Seconds
036F D002       402            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0371 209010     403            jb SEC_BUTTON, check_am_pm ; if the 'CLEAR' button is not pressed skip
0374            404            
0374 E535       405            mov a, BCD_counter_temp ;incrementing the minutes
0376 2401       406            add a, #0x01
0378 D4         407            da a
0379            408            
0379 B46006     409            cjne a, #0x60, no_o_flow_sec  ;making it clr if minutes too high
037C E4         410            clr a
037D 7400       411            mov a, #0x00
037F D4         412            da a
0380 F535       413            mov BCD_counter_temp, a
0382            414            
0382            415   no_o_flow_sec:
0382 F535       416            mov BCD_counter_temp, a
0384            417            
0384            418   check_am_pm:
0384 209143     419            jb AM_PM, check_set  ; if the 'CLEAR' button is not pressed skip
0387 C002       420            push AR2
0389 7A96       420            mov R2, #150
038B 120038     420            lcall ?Wait_Milli_Seconds
038E D002       420            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0390 209137     421            jb AM_PM, check_set ; if the 'CLEAR' button is not pressed skip
0393            422            
0393            423            ;have R1 be whether the clk is AM or PM
0393            424            ;if R1 is 0 it is AM, if its 1 its PM
0393 E53A       425            mov a, clk_am_pm
0395 701B       426            jnz change_to_am
0397            427            
0397            428   change_to_pm:
0397 753A01     429            mov clk_am_pm, #0x01
039A C0E0       430            push acc
039C 7410       430            mov a, #16
039E 14         430            dec a
039F 1200C7     430            lcall ?Set_Cursor_1 ; Select column and row
03A2 D0E0       430            pop acc
03A4 C0E0       431            push acc
03A6 7450       431            mov a, #'P'
03A8 12007D     431            lcall ?WriteData
03AB D0E0       431            pop acc                 
03AD 801B       432            sjmp check_set
03AF            433            
03AF            434   jump_extend: ;extending the jump to setting time
03AF 0202EC     435            ljmp setting_time       
03B2            436            
03B2            437   change_to_am:
03B2 753A00     438            mov clk_am_pm, #0x0
03B5 C0E0       439            push acc
03B7 7410       439            mov a, #16
03B9 14         439            dec a
03BA 1200C7     439            lcall ?Set_Cursor_1 ; Select column and row
03BD D0E0       439            pop acc
03BF C0E0       440            push acc
03C1 7441       440            mov a, #'A'
03C3 12007D     440            lcall ?WriteData
03C6 D0E0       440            pop acc
03C8 8000       441            sjmp check_set
03CA            442            
03CA            443   check_set:       
03CA 2092E2     444            jb SET_IT, jump_extend  ; if the 'SET_IT' button is not pressed skip
03CD C002       445            push AR2
03CF 7A32       445            mov R2, #50
03D1 120038     445            lcall ?Wait_Milli_Seconds
03D4 D002       445            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03D6 2092D6     446            jb SET_IT, jump_extend ; if the 'SET_IT' button is not pressed skip
03D9            447            
03D9 7B00       448            mov R3, #0
03DB            449            
03DB            450            ;moving the counters over to their real counterparts which are used by Timer 2
03DB            451            ;the temp variables helped prevent the timer from increasing them as they were being entered
03DB C0E0       452            push acc
03DD 7401       452            mov a, #1
03DF 14         452            dec a
03E0 1200C5     452            lcall ?Set_Cursor_2 ; Select column and row
03E3 D0E0       452            pop acc
03E5 853532     453            mov BCD_Counter, BCD_Counter_temp
03E8 853633     454            mov BCD_Counter1, BCD_Counter1_temp
03EB 853734     455            mov BCD_Counter2, BCD_Counter2_temp
03EE C083       456            push dph
03F0 C082       456            push dpl
03F2 C0E0       456            push acc
03F4 900115     456            mov dptr, #Alarm_Off
03F7 1200BA     456            lcall ?Send_Constant_String
03FA D0E0       456            pop acc
03FC D082       456            pop dpl
03FE D083       456            pop dph;string to say alarm is in off mode
0400            457            
0400            458            ; After initialization the program stays in this 'forever' loop
0400            459   loop:
0400            460                    
0400            461       
0400            462   check_clk_am_set:
0400 E53A       463            mov a, clk_am_pm
0402 7015       464            jnz set_clk_pm
0404            465            
0404            466   set_clk_am:      
0404 C0E0       467            push acc
0406 7410       467            mov a, #16
0408 14         467            dec a
0409 1200C7     467            lcall ?Set_Cursor_1 ; Select column and row
040C D0E0       467            pop acc
040E C0E0       468            push acc
0410 7441       468            mov a, #'A'
0412 12007D     468            lcall ?WriteData
0415 D0E0       468            pop acc
0417 8013       469            sjmp check_alarm_hour
0419            470            
0419            471   set_clk_pm:
0419 C0E0       472            push acc
041B 7410       472            mov a, #16
041D 14         472            dec a
041E 1200C7     472            lcall ?Set_Cursor_1 ; Select column and row
0421 D0E0       472            pop acc
0423 C0E0       473            push acc
0425 7450       473            mov a, #'P'
0427 12007D     473            lcall ?WriteData
042A D0E0       473            pop acc
042C            474            
042C            475   
042C            476   check_alarm_hour:        
042C C0E0       477            push acc
042E 7407       477            mov a, #7
0430 14         477            dec a
0431 1200C5     477            lcall ?Set_Cursor_2 ; Select column and row
0434 D0E0       477            pop acc
0436 C000       478            push ar0
0438 A839       478            mov r0, BCD_alarm_hour
043A 1200CC     478            lcall ?Display_BCD
043D D000       478            pop ar0
043F            479            
043F 20961E     480            jb HR_BUTTON, check_alarm_mins  ; if the 'CLEAR' button is not pressed skip
0442 C002       481            push AR2
0444 7A64       481            mov R2, #100
0446 120038     481            lcall ?Wait_Milli_Seconds
0449 D002       481            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
044B 209612     482            jb HR_BUTTON, check_alarm_mins ; if the 'CLEAR' button is not pressed skip
044E            483            
044E E539       484            mov a, BCD_alarm_hour ;incrementing the minutes
0450 2401       485            add a, #0x01
0452 D4         486            da a
0453            487            
0453 B41308     488            cjne a, #0x13, no_o_flow_alarm_hr  ;making it clr if hour too high
0456 E4         489            clr a
0457 7401       490            mov a, #0x01
0459 D4         491            da a
045A F539       492            mov BCD_alarm_hour, a
045C            493            
045C 8002       494            sjmp check_alarm_mins
045E            495            ;need to deal with overflow
045E            496   no_o_flow_alarm_hr:
045E F539       497            mov BCD_alarm_hour, a
0460            498   
0460            499   check_alarm_mins:        
0460 C0E0       500            push acc
0462 740A       500            mov a, #10
0464 14         500            dec a
0465 1200C5     500            lcall ?Set_Cursor_2 ; Select column and row
0468 D0E0       500            pop acc
046A C000       501            push ar0
046C A838       501            mov r0, BCD_alarm_min
046E 1200CC     501            lcall ?Display_BCD
0471 D000       501            pop ar0
0473            502            
0473 20951C     503            jb MIN_BUTTON, check_alarm_am_pm  ; if the 'CLEAR' button is not pressed skip
0476 C002       504            push AR2
0478 7A64       504            mov R2, #100
047A 120038     504            lcall ?Wait_Milli_Seconds
047D D002       504            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
047F 209510     505            jb MIN_BUTTON, check_alarm_am_pm ; if the 'CLEAR' button is not pressed skip
0482            506            
0482 E538       507            mov a, BCD_alarm_min ;incrementing the minutes
0484 2401       508            add a, #0x01
0486 D4         509            da a
0487            510            
0487 B46006     511            cjne a, #0x60, no_o_flow_alarm_min  ;making it clr if minutes too high
048A E4         512            clr a
048B 7400       513            mov a, #0x00
048D D4         514            da a
048E F538       515            mov BCD_alarm_min, a
0490            516            
0490            517   no_o_flow_alarm_min:
0490 F538       518            mov BCD_alarm_min, a
0492            519            
0492            520   check_alarm_am_pm:
0492 20913E     521            jb AM_PM, check_alarm_set  ; if the 'CLEAR' button is not pressed skip
0495 C002       522            push AR2
0497 7AFA       522            mov R2, #250
0499 120038     522            lcall ?Wait_Milli_Seconds
049C D002       522            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
049E 209132     523            jb AM_PM, check_alarm_set ; if the 'CLEAR' button is not pressed skip
04A1            524            
04A1            525            ;have R1 be whether the clk is AM or PM
04A1            526            ;if R1 is 0 it is AM, if its 1 its PM
04A1 E53B       527            mov a, alarm_am_pm
04A3 7018       528            jnz change_to_alarm_am
04A5            529            
04A5            530   change_to_alarm_pm:
04A5 753B01     531            mov alarm_am_pm, #0x1
04A8 C0E0       532            push acc
04AA 740D       532            mov a, #13
04AC 14         532            dec a
04AD 1200C5     532            lcall ?Set_Cursor_2 ; Select column and row
04B0 D0E0       532            pop acc
04B2 C0E0       533            push acc
04B4 7450       533            mov a, #'P'
04B6 12007D     533            lcall ?WriteData
04B9 D0E0       533            pop acc                 
04BB 8016       534            sjmp check_alarm_set
04BD            535   
04BD            536            
04BD            537   change_to_alarm_am:
04BD 753B00     538            mov alarm_am_pm, #0x0
04C0 C0E0       539            push acc
04C2 740D       539            mov a, #13
04C4 14         539            dec a
04C5 1200C5     539            lcall ?Set_Cursor_2 ; Select column and row
04C8 D0E0       539            pop acc
04CA C0E0       540            push acc
04CC 7441       540            mov a, #'A'
04CE 12007D     540            lcall ?WriteData
04D1 D0E0       540            pop acc
04D3            541            ;sjmp check_set
04D3            542            
04D3            543   check_alarm_set:
04D3            544            
04D3 E53B       545            mov a, alarm_am_pm
04D5 7015       546            jnz set_pm
04D7            547            
04D7            548   set_am:  
04D7 C0E0       549            push acc
04D9 740D       549            mov a, #13
04DB 14         549            dec a
04DC 1200C5     549            lcall ?Set_Cursor_2 ; Select column and row
04DF D0E0       549            pop acc
04E1 C0E0       550            push acc
04E3 7441       550            mov a, #'A'
04E5 12007D     550            lcall ?WriteData
04E8 D0E0       550            pop acc
04EA 8013       551            sjmp display
04EC            552            
04EC            553   set_pm:
04EC C0E0       554            push acc
04EE 740D       554            mov a, #13
04F0 14         554            dec a
04F1 1200C5     554            lcall ?Set_Cursor_2 ; Select column and row
04F4 D0E0       554            pop acc
04F6 C0E0       555            push acc
04F8 7450       555            mov a, #'P'
04FA 12007D     555            lcall ?WriteData
04FD D0E0       555            pop acc
04FF            556            
04FF            557            
04FF            558   display:
04FF C0E0       559            push acc
0501 740D       559            mov a, #13
0503 14         559            dec a
0504 1200C7     559            lcall ?Set_Cursor_1 ; Select column and row
0507 D0E0       559            pop acc     ; the place in the LCD where we want the BCD counter value
0509 C000       560            push ar0
050B A832       560            mov r0, BCD_counter
050D 1200CC     560            lcall ?Display_BCD
0510 D000       560            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0512            561            
0512 C0E0       562            push acc
0514 740A       562            mov a, #10
0516 14         562            dec a
0517 1200C7     562            lcall ?Set_Cursor_1 ; Select column and row
051A D0E0       562            pop acc
051C C000       563            push ar0
051E A833       563            mov r0, BCD_counter1
0520 1200CC     563            lcall ?Display_BCD
0523 D000       563            pop ar0
0525            564            
0525 C0E0       565            push acc
0527 7407       565            mov a, #7
0529 14         565            dec a
052A 1200C7     565            lcall ?Set_Cursor_1 ; Select column and row
052D D0E0       565            pop acc
052F C000       566            push ar0
0531 A834       566            mov r0, BCD_counter2
0533 1200CC     566            lcall ?Display_BCD
0536 D000       566            pop ar0
0538            567            
0538 C0E0       568            push acc
053A 740A       568            mov a, #10
053C 14         568            dec a
053D 1200C5     568            lcall ?Set_Cursor_2 ; Select column and row
0540 D0E0       568            pop acc
0542 C000       569            push ar0
0544 A838       569            mov r0, BCD_alarm_min
0546 1200CC     569            lcall ?Display_BCD
0549 D000       569            pop ar0
054B            570            
054B C0E0       571            push acc
054D 7407       571            mov a, #7
054F 14         571            dec a
0550 1200C5     571            lcall ?Set_Cursor_2 ; Select column and row
0553 D0E0       571            pop acc
0555 C000       572            push ar0
0557 A839       572            mov r0, BCD_alarm_hour
0559 1200CC     572            lcall ?Display_BCD
055C D000       572            pop ar0
055E            573   
055E            574   check_the_alarm:
055E            575            ;check if AM/PM the same: R2 stores alarm, R1 stores clk
055E            576            ;check if hours the same
055E 209252     577            jb SET_IT, check_if_alarm_set  ; if the 'CLEAR' button is not pressed skip
0561 C002       578            push AR2
0563 7A64       578            mov R2, #100
0565 120038     578            lcall ?Wait_Milli_Seconds
0568 D002       578            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
056A 209246     579            jb SET_IT, check_if_alarm_set
056D            580            
056D EB         581            mov a, R3 ;checking whether alarm is set
056E B40122     582            cjne a, #1, set_alarm_on
0571            583                    
0571            584   turn_alarm_off:
0571 E4         585            clr a
0572 7400       586            mov a, #0x00
0574 FB         587            mov R3, a
0575            588            
0575 C0E0       589            push acc
0577 7401       589            mov a, #1
0579 14         589            dec a
057A 1200C5     589            lcall ?Set_Cursor_2 ; Select column and row
057D D0E0       589            pop acc
057F C083       590            push dph
0581 C082       590            push dpl
0583 C0E0       590            push acc
0585 900115     590            mov dptr, #Alarm_Off
0588 1200BA     590            lcall ?Send_Constant_String
058B D0E0       590            pop acc
058D D082       590            pop dpl
058F D083       590            pop dph
0591 8020       591            sjmp check_if_alarm_set
0593            592            
0593            593   set_alarm_on:
0593 E4         594            clr a
0594 7401       595            mov a, #0x01
0596 FB         596            mov R3, a
0597            597            
0597 C0E0       598            push acc
0599 7401       598            mov a, #1
059B 14         598            dec a
059C 1200C5     598            lcall ?Set_Cursor_2 ; Select column and row
059F D0E0       598            pop acc
05A1 C083       599            push dph
05A3 C082       599            push dpl
05A5 C0E0       599            push acc
05A7 900104     599            mov dptr, #Alarm_On
05AA 1200BA     599            lcall ?Send_Constant_String
05AD D0E0       599            pop acc
05AF D082       599            pop dpl
05B1 D083       599            pop dph         
05B3            600   
05B3            601   
05B3            602   check_if_alarm_set:
05B3 EB         603            mov a, R3
05B4 B4012A     604            cjne a, #0x01, no_alarm
05B7            605                    
05B7            606   comp_am_pm: ;whether alarm am and pm are the same as the clock's
05B7 E53A       607            mov a, clk_am_pm
05B9 953B       608            subb a, alarm_am_pm
05BB D4         609            da a 
05BC B40022     610            cjne a, #0x00, no_alarm
05BF            611            
05BF E53B       612            mov a, alarm_am_pm
05C1 953A       613            subb a, clk_am_pm
05C3 D4         614            da a 
05C4 B4001A     615            cjne a, #0x00, no_alarm
05C7            616   
05C7            617   comp_hour:;whether alarm's hours are the same as the clock's
05C7 E534       618            mov a, BCD_counter2
05C9 9539       619            subb a, BCD_alarm_hour
05CB D4         620            da a 
05CC B40012     621            cjne a, #0x00, no_alarm
05CF            622            
05CF E539       623            mov a, BCD_alarm_hour
05D1 9534       624            subb a, BCD_counter2
05D3 D4         625            da a 
05D4 B4000A     626            cjne a, #0x00, no_alarm
05D7            627   
05D7            628   comp_min:;whether alarm's minutes are the same as the clock's
05D7 E533       629            mov a, BCD_counter1
05D9 9538       630            subb a, BCD_alarm_min
05DB D4         631            da a 
05DC B40002     632            cjne a, #0x00, no_alarm
05DF 8003       633            sjmp sound_the_alarm
05E1            634                    
05E1            635   no_alarm:
05E1 020870     636            ljmp loop_a ;skip the alarm sequence
05E4            637            
05E4            638            
05E4            639   sound_the_alarm:
05E4 BB01FA     640            cjne R3, #0x01, no_alarm ;safety measure to ensure alarm does not go off incorrectly
05E7 753C00     641            mov alarm_ans, #0x00
05EA            642            
05EA D2A9       643            setb ET0  ; Enable timer 0 interrupt, timer zero interrupt sounds the alarm
05EC            644   
05EC            645            ;check which message should be displayed
05EC E53D       646            mov a, q_count
05EE B4003B     647            cjne a, #0x00, question_1_disp
05F1            648            
05F1            649   question_0_disp:
05F1 C0E0       650            push acc
05F3 7401       650            mov a, #1
05F5 14         650            dec a
05F6 1200C7     650            lcall ?Set_Cursor_1 ; Select column and row
05F9 D0E0       650            pop acc
05FB C083       651            push dph
05FD C082       651            push dpl
05FF C0E0       651            push acc
0601 90012A     651            mov dptr, #ALARM_1
0604 1200BA     651            lcall ?Send_Constant_String
0607 D0E0       651            pop acc
0609 D082       651            pop dpl
060B D083       651            pop dph
060D C0E0       652            push acc
060F 7401       652            mov a, #1
0611 14         652            dec a
0612 1200C5     652            lcall ?Set_Cursor_2 ; Select column and row
0615 D0E0       652            pop acc
0617 C083       653            push dph
0619 C082       653            push dpl
061B C0E0       653            push acc
061D 90013C     653            mov dptr, #ALARM_2
0620 1200BA     653            lcall ?Send_Constant_String
0623 D0E0       653            pop acc
0625 D082       653            pop dpl
0627 D083       653            pop dph
0629 020742     654            ljmp check_ans_button
062C            655            
062C            656   question_1_disp:
062C B4013B     657            cjne a, #0x01, question_2_disp
062F C0E0       658            push acc
0631 7401       658            mov a, #1
0633 14         658            dec a
0634 1200C7     658            lcall ?Set_Cursor_1 ; Select column and row
0637 D0E0       658            pop acc
0639 C083       659            push dph
063B C082       659            push dpl
063D C0E0       659            push acc
063F 900176     659            mov dptr, #ALARM_3
0642 1200BA     659            lcall ?Send_Constant_String
0645 D0E0       659            pop acc
0647 D082       659            pop dpl
0649 D083       659            pop dph
064B C0E0       660            push acc
064D 7401       660            mov a, #1
064F 14         660            dec a
0650 1200C5     660            lcall ?Set_Cursor_2 ; Select column and row
0653 D0E0       660            pop acc
0655 C083       661            push dph
0657 C082       661            push dpl
0659 C0E0       661            push acc
065B 900187     661            mov dptr, #ALARM_4
065E 1200BA     661            lcall ?Send_Constant_String
0661 D0E0       661            pop acc
0663 D082       661            pop dpl
0665 D083       661            pop dph
0667 020742     662            ljmp check_ans_button
066A            663            
066A            664   question_2_disp:
066A C0E0       665            push acc
066C 7401       665            mov a, #1
066E 14         665            dec a
066F 1200C7     665            lcall ?Set_Cursor_1 ; Select column and row
0672 D0E0       665            pop acc
0674 C083       666            push dph
0676 C082       666            push dpl
0678 C0E0       666            push acc
067A 900198     666            mov dptr, #ALARM_5
067D 1200BA     666            lcall ?Send_Constant_String
0680 D0E0       666            pop acc
0682 D082       666            pop dpl
0684 D083       666            pop dph
0686 C0E0       667            push acc
0688 7401       667            mov a, #1
068A 14         667            dec a
068B 1200C5     667            lcall ?Set_Cursor_2 ; Select column and row
068E D0E0       667            pop acc
0690 C083       668            push dph
0692 C082       668            push dpl
0694 C0E0       668            push acc
0696 9001A9     668            mov dptr, #ALARM_6
0699 1200BA     668            lcall ?Send_Constant_String
069C D0E0       668            pop acc
069E D082       668            pop dpl
06A0 D083       668            pop dph
06A2 020742     669            ljmp check_ans_button           
06A5            670            
06A5            671   fail_message:
06A5 C0E0       672            push acc
06A7 7401       672            mov a, #1
06A9 14         672            dec a
06AA 1200C7     672            lcall ?Set_Cursor_1 ; Select column and row
06AD D0E0       672            pop acc
06AF C083       673            push dph
06B1 C082       673            push dpl
06B3 C0E0       673            push acc
06B5 900150     673            mov dptr, #FAIL_1
06B8 1200BA     673            lcall ?Send_Constant_String
06BB D0E0       673            pop acc
06BD D082       673            pop dpl
06BF D083       673            pop dph
06C1 C0E0       674            push acc
06C3 7401       674            mov a, #1
06C5 14         674            dec a
06C6 1200C5     674            lcall ?Set_Cursor_2 ; Select column and row
06C9 D0E0       674            pop acc
06CB C083       675            push dph
06CD C082       675            push dpl
06CF C0E0       675            push acc
06D1 900163     675            mov dptr, #FAIL_2
06D4 1200BA     675            lcall ?Send_Constant_String
06D7 D0E0       675            pop acc
06D9 D082       675            pop dpl
06DB D083       675            pop dph
06DD C002       676            push AR2
06DF 7AC8       676            mov R2, #200
06E1 120038     676            lcall ?Wait_Milli_Seconds
06E4 D002       676            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'                 
06E6 C002       677            push AR2
06E8 7AC8       677            mov R2, #200
06EA 120038     677            lcall ?Wait_Milli_Seconds
06ED D002       677            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
06EF C002       678            push AR2
06F1 7AC8       678            mov R2, #200
06F3 120038     678            lcall ?Wait_Milli_Seconds
06F6 D002       678            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
06F8 C002       679            push AR2
06FA 7AC8       679            mov R2, #200
06FC 120038     679            lcall ?Wait_Milli_Seconds
06FF D002       679            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0701 C002       680            push AR2
0703 7AC8       680            mov R2, #200
0705 120038     680            lcall ?Wait_Milli_Seconds
0708 D002       680            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
070A C0E0       681            push acc
070C 7401       681            mov a, #1
070E 14         681            dec a
070F 1200C7     681            lcall ?Set_Cursor_1 ; Select column and row
0712 D0E0       681            pop acc
0714 C083       682            push dph
0716 C082       682            push dpl
0718 C0E0       682            push acc
071A 90012A     682            mov dptr, #ALARM_1
071D 1200BA     682            lcall ?Send_Constant_String
0720 D0E0       682            pop acc
0722 D082       682            pop dpl
0724 D083       682            pop dph
0726 C0E0       683            push acc
0728 7401       683            mov a, #1
072A 14         683            dec a
072B 1200C5     683            lcall ?Set_Cursor_2 ; Select column and row
072E D0E0       683            pop acc
0730 C083       684            push dph
0732 C082       684            push dpl
0734 C0E0       684            push acc
0736 90013C     684            mov dptr, #ALARM_2
0739 1200BA     684            lcall ?Send_Constant_String
073C D0E0       684            pop acc
073E D082       684            pop dpl
0740 D083       684            pop dph
0742            685            
0742            686   check_ans_button:
0742            687            
0742 C0E0       688            push acc
0744 740F       688            mov a, #15
0746 14         688            dec a
0747 1200C5     688            lcall ?Set_Cursor_2 ; Select column and row
074A D0E0       688            pop acc
074C C000       689            push ar0
074E A83C       689            mov r0, alarm_ans
0750 1200CC     689            lcall ?Display_BCD
0753 D000       689            pop ar0
0755            690            
0755 209024     691            jb SEC_BUTTON, check_ans ; if the 'CLEAR' button is not pressed skip
0758 C002       692            push AR2
075A 7A64       692            mov R2, #100
075C 120038     692            lcall ?Wait_Milli_Seconds
075F D002       692            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0761 209018     693            jb SEC_BUTTON, check_ans ; if the 'CLEAR' button is not pressed skip
0764            694            
0764 E53C       695            mov a, alarm_ans ;incrementing the minutes
0766 2401       696            add a, #0x01
0768 D4         697            da a
0769            698            
0769 B41006     699            cjne a, #0x10, no_o_flow_ans  ;making it clr if minutes too high
076C E4         700            clr a
076D 7400       701            mov a, #0x00
076F D4         702            da a
0770 F53C       703            mov alarm_ans, a
0772            704            
0772            705            
0772            706   no_o_flow_ans:
0772 F53C       707            mov alarm_ans, a
0774 8006       708            sjmp check_ans
0776            709            
0776            710   check_ans_button_extend:
0776 020742     711            ljmp check_ans_button
0779            712   
0779            713   fail_message_extend: ;can't reach
0779 0206A5     714            ljmp fail_message
077C            715   
077C            716   check_ans:
077C            717            ;using the set_button
077C 2092F7     718            jb SET_IT, check_ans_button_extend ; if the 'SET_IT' button is not pressed skip
077F C002       719            push AR2
0781 7A64       719            mov R2, #100
0783 120038     719            lcall ?Wait_Milli_Seconds
0786 D002       719            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0788 2092EB     720            jb SET_IT, check_ans_button_extend ; if the 'SET_IT' button is not pressed skip         
078B            721            
078B            722            ;if answer is right continue
078B E53D       723            mov a, q_count
078D B40016     724            cjne a, #0x00, question_1_check
0790            725            
0790            726   question_0_check: ;want answer 8         
0790 E53C       727            mov a, alarm_ans
0792 9408       728            subb a, #0x08
0794 D4         729            da a 
0795 B400E1     730            cjne a, #0x00, fail_message_extend
0798 7408       731            mov a, #0x08
079A            732            
079A 953C       733            subb a, alarm_ans
079C D4         734            da a 
079D B400D9     735            cjne a, #0x00, fail_message_extend
07A0 753D01     736            mov q_count, #0x01
07A3 0207D5     737            ljmp question_passed
07A6            738            
07A6            739   question_1_check:
07A6 B40116     740            cjne a, #0x01, question_2_check
07A9 E53C       741            mov a, alarm_ans
07AB 9406       742            subb a, #0x06
07AD D4         743            da a 
07AE B400C8     744            cjne a, #0x00, fail_message_extend
07B1 7406       745            mov a, #0x06
07B3            746            
07B3 953C       747            subb a, alarm_ans
07B5 D4         748            da a 
07B6 B400C0     749            cjne a, #0x00, fail_message_extend
07B9 753D02     750            mov q_count, #0x02
07BC 0207D5     751            ljmp question_passed
07BF            752            
07BF            753   question_2_check:
07BF E53C       754            mov a, alarm_ans
07C1 9407       755            subb a, #0x07
07C3 D4         756            da a 
07C4 B400B2     757            cjne a, #0x00, fail_message_extend
07C7 7407       758            mov a, #0x07
07C9            759            
07C9 953C       760            subb a, alarm_ans
07CB D4         761            da a 
07CC B400AA     762            cjne a, #0x00, fail_message_extend
07CF 753D00     763            mov q_count, #0x00
07D2 0207D5     764            ljmp question_passed
07D5            765            
07D5            766   question_passed:         
07D5 7B00       767            mov R3, #0x00
07D7 C2A9       768            clr ET0  ; Enable timer 0 interrupt
07D9            769            
07D9 C0E0       770            push acc
07DB 7401       770            mov a, #1
07DD 14         770            dec a
07DE 1200C7     770            lcall ?Set_Cursor_1 ; Select column and row
07E1 D0E0       770            pop acc
07E3 C083       771            push dph
07E5 C082       771            push dpl
07E7 C0E0       771            push acc
07E9 9000E2     771            mov dptr, #Initial_Message
07EC 1200BA     771            lcall ?Send_Constant_String
07EF D0E0       771            pop acc
07F1 D082       771            pop dpl
07F3 D083       771            pop dph
07F5            772       
07F5 C0E0       773            push acc
07F7 7401       773            mov a, #1
07F9 14         773            dec a
07FA 1200C5     773            lcall ?Set_Cursor_2 ; Select column and row
07FD D0E0       773            pop acc
07FF C083       774            push dph
0801 C082       774            push dpl
0803 C0E0       774            push acc
0805 9000F3     774            mov dptr, #Initial_Message2
0808 1200BA     774            lcall ?Send_Constant_String
080B D0E0       774            pop acc
080D D082       774            pop dpl
080F D083       774            pop dph         
0811            775       
0811 C0E0       776            push acc
0813 740D       776            mov a, #13
0815 14         776            dec a
0816 1200C7     776            lcall ?Set_Cursor_1 ; Select column and row
0819 D0E0       776            pop acc     ; the place in the LCD where we want the BCD counter value
081B C000       777            push ar0
081D A832       777            mov r0, BCD_counter
081F 1200CC     777            lcall ?Display_BCD
0822 D000       777            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0824            778            
0824 C0E0       779            push acc
0826 740A       779            mov a, #10
0828 14         779            dec a
0829 1200C7     779            lcall ?Set_Cursor_1 ; Select column and row
082C D0E0       779            pop acc
082E C000       780            push ar0
0830 A833       780            mov r0, BCD_counter1
0832 1200CC     780            lcall ?Display_BCD
0835 D000       780            pop ar0
0837            781            
0837 C0E0       782            push acc
0839 7407       782            mov a, #7
083B 14         782            dec a
083C 1200C7     782            lcall ?Set_Cursor_1 ; Select column and row
083F D0E0       782            pop acc
0841 C000       783            push ar0
0843 A834       783            mov r0, BCD_counter2
0845 1200CC     783            lcall ?Display_BCD
0848 D000       783            pop ar0
084A            784            
084A C0E0       785            push acc
084C 740A       785            mov a, #10
084E 14         785            dec a
084F 1200C5     785            lcall ?Set_Cursor_2 ; Select column and row
0852 D0E0       785            pop acc
0854 C000       786            push ar0
0856 A838       786            mov r0, BCD_alarm_min
0858 1200CC     786            lcall ?Display_BCD
085B D000       786            pop ar0
085D            787            
085D C0E0       788            push acc
085F 7407       788            mov a, #7
0861 14         788            dec a
0862 1200C5     788            lcall ?Set_Cursor_2 ; Select column and row
0865 D0E0       788            pop acc
0867 C000       789            push ar0
0869 A839       789            mov r0, BCD_alarm_hour
086B 1200CC     789            lcall ?Display_BCD
086E D000       789            pop ar0
0870            790   
0870            791   loop_a:
0870            792   
0870 300002     793            jnb half_seconds_flag, loop_extend
0873 8003       794            sjmp loop_b
0875            795            
0875            796            
0875            797   loop_extend:
0875 020400     798            ljmp loop
0878            799   loop_b:
0878 C200       800            clr half_seconds_flag 
087A 020400     801       ljmp loop
087D            802   END
